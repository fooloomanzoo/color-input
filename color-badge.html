<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../polymer/lib/utils/mixin.html">
<link rel="import" href="../property-mixins/color-mixin.html">
<link rel="import" href="../input-picker-pattern/input-shared-style.html">

<script>
  /**
   * Mixin for color-badge
   *
   * @mixinFunction
   * @polymer
   */
  const ColorBadgePattern = function(superClass) {

    return class extends superClass { // eslint-disable-line no-unused-vars, no-undef

      static get styleToInclude() {
        return 'input-shared-style';
      }

      static get styleTemplate() {
        return `
          :host {
            --computed-transparency-pattern-position: calc(var(--transparency-pattern-size, 0.75em) / 2);
          }
          :host(:not([hide-transparency-pattern])) .transparency:before {
            background-image: var(--transparency-pattern, linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.1) 75%, rgba(0,0,0,0.1)), linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.1) 75%, rgba(0,0,0,0.1)));
            background-size: var(--transparency-pattern-size, 0.75em) var(--transparency-pattern-size, 0.75em);
            background-position: 0 0, var(--computed-transparency-pattern-position) var(--computed-transparency-pattern-position);
            background-repeat: repeat;
            -webkit-background-clip: padding-box;
            background-clip: padding-box;
            background-repeat: repeat;
            border-radius: var(--color-badge-radius, 6px);
            content: '';
            pointer-events: none;
            position: absolute;
            top: 0; right: 0; bottom: 0; left: 0;
          }
          .badge {
            position: relative;
            border: none;
            box-sizing: content-box;
            box-shadow: var(--color-badge-shadow, 0 1px 4px 1px rgba(0,0,0,.1));
            border-radius: var(--color-badge-radius, 6px);
            background-color: #fff;
            height: var(--color-badge-height, 32px);
            width: var(--color-badge-width, 60px);
          }
          .badge > canvas {
            border-radius: inherit;
            position: absolute;
            left: 0;
            top: 0;
          }
          .badge > .slot {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            @apply --color-badge-slot;
          }
          ${super.styleTemplate || ''}
        `;
      }

      static get colorBadgeTemplate() {
        return `
          <div id="colorBadge" class="transparency badge">
            <canvas id="badge" width$="[[_badgeWidth]]" height$="[[_badgeHeight]]"></canvas>
            ${this.colorBadgeSlotTemplate || ''}
          </div>
        `
      }

      static get colorBadgeSlotTemplate() {
        return `
          <div class="slot"><slot></slot></div>
        `
      }

      static get properties() {
        return {
          /**
           * hide the transparency pattern
           */
          hideTransparencyPattern: {
            type: Boolean,
            reflectToAttribute: true
          },

          /**
           * if true, clicking on the color badge won't generate a random color
           */
          noRandomColorOnClick: {
            type: Boolean,
            value: false,
            observer: '_noRandomColorOnClickChanged'
          },

          _badgeWidth: {
            type: Number
          },

          _badgeHeight: {
            type: Number
          },

          _badgeContext: {
            type: CanvasRenderingContext2D
          }
        }
      }

      static get observers() {
        return [
          '_draw(_badgeContext,colorString,_badgeWidth,_badgeHeight)'
        ]
      }

      ready() {
        super.ready();
        this._computeSizeProperties();
        this._computeContexts();
      }

      connectedCallback() {
        super.connectedCallback();
        this.render();
      }

      /**
       * render the element
       */
      render() {
        this._draw(this._colorBadge, this.colorString, this._badgeWidth, this._badgeHeight);
      }

      /**
       * generates a random color
       */
      randomColor(e) {
        if (e && e.preventDefault) {
          e.preventDefault();
          e.stopPropagation();
        }
        super.randomColor();
      }

      /**
       * @typedef {Object} CanvasRenderingContext2D context of a canvas element
       */

      /**
       * fills a canvas context with a color
       * @param  {CanvasRenderingContext2D} context The context of the canvas that should be drawn.
       * @param  {String} colorString The color string to be drawn.
       * @param  {Number} width   The width to draw within the canvas.
       * @param  {Number} height  The height to draw within the canvas
       */
      _draw(context, colorString, width, height) {
        if (context === undefined || width === undefined || height === undefined) {
          return;
        }
        context.clearRect(0, 0, width, height);
        context.fillStyle = colorString || 'rgba(0,0,0,0)';
        context.fillRect(0, 0, width, height);
      }

      /**
       * computes the canvas contexts of the element
       */
      _computeContexts() {
        const badge = this.shadowRoot.querySelector('#badge');
        if (badge) {
          this._badgeContext = badge.getContext("2d");
        }
      }

      /**
       * computes the size properties for the canvas
       */
      _computeSizeProperties() {
        // use the container of the badge to define its draw area
        const badgeContainer = this.shadowRoot.querySelector('#colorBadge');
        if (badgeContainer) {
          const box = badgeContainer.getBoundingClientRect();
          if (box.width !== this._badgeWidth || box.height !== this._badgeHeight) {
            this.setProperties({
              _badgeWidth: Math.ceil(box.width) || 16,
              _badgeHeight: Math.ceil(box.height) || 16
            });
          }
        }
      }

      _noRandomColorOnClickChanged(noRandomColorOnClick) {
        if (noRandomColorOnClick) {
          this._removeClickListenerForBadge();
        } else {
          this._addClickListenerForBadge();
        }
      }

      _addClickListenerForBadge() {
        if (this.$.badge) {
          this.$.badge.addEventListener('click', this.randomColor, false);
          this.$.badge.addEventListener('contextmenu', this.randomColor, false);
        }
      }

      _removeClickListenerForBadge() {
        if (this.$.badge) {
          this.$.badge.removeEventListener('click', this.randomColor, false);
          this.$.badge.removeEventListener('contextmenu', this.randomColor, false);
        }
      }

    }
  }
  window.ColorBadgePattern = Polymer.dedupingMixin(ColorBadgePattern);
</script>

<dom-module id="color-badge">
  <script>
  /**
  * `<color-badge>` is a badge that displays a color as a rectangle with a specified height and width.
  * The transparency of the color will be displayed. It can slot elements and they are automatically centered. Because of using a canvas to draw the color, it needs to be explicitly sized via the width- and height-attribute.
  * Click on the badge to generate a random color.
  *
  *   ```html
  *     <color-badge height="24" width="96" value="[[color]]">
  *       <span>[[color]]</span>
  *     </color-badge>
  *   ```
  *
  * Custom property | Description | Default
  * ----------------|-------------|----------
  * `--transparency-pattern` | background pattern for the transparency layer | linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.1) 75%, rgba(0,0,0,0.1)), linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.1) 75%, rgba(0,0,0,0.1)))
  * `--transparency-pattern-size` | size transparency pattern | 0.75em
  * `--color-badge-radius` | border-radius of the badge | 6px
  * `--color-badge-shadow` | box-shadow of the badge | 0 1px 4px 1px rgba(0,0,0,.1)
  * `--color-badge-height` | height of the badge | 32px
  * `--color-badge-width` | width of the badge | 60px
  * `--color-badge-slot` | mixin applied to the slot of the badge | {}
  *
  * @customElement
  * @polymer
  *
  * @appliesMixin ColorBadgePattern
  * @appliesMixin ColorMixin
  * @appliesMixin FormElementMixin
  *
  * @demo demo/badge.html
  **/
    class ColorBadge extends ColorBadgePattern(ColorMixin(Polymer.Element)) { // eslint-disable-line no-undef

      static get is() {
        return 'color-badge';
      }

      static get template() {
        return `
          <style include="${this.styleToInclude}">
            ${this.styleTemplate}
          </style>
          ${this.colorBadgeTemplate}
        `;
      }
    }
    window.customElements.define(ColorBadge.is, ColorBadge);
  </script>
</dom-module>
